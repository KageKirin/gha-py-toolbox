name: DOTNET commit packages versions
description: >
  Commits updated packages versions by performs the following steps:
  1. split the modified file (e.g. Directory.Packages.props) into a series of single-line-patches.
  2. commit those patches.

inputs:
  path:
    description: path from where to run the actions
    required: false
    default: ${{github.workspace}}
  package-regex:
    description: >
      Space-separated list.
    required: true
  package-xpath:
    description: >
      XPath expression to locate package entries.
      WARNING: Defaults to <PackageVersion/> elements as used by Build.Packages.props.
    required: true
    default: //PackageVersion
  configuration-file:
    description: >
      Configuration file (props or csproj) to check for packages.
      Defaults to Build.Packages.props.
    required: false
    default: Build.Packages.props

  packages:
    description: JSON string of dictionary mapping the retrieved packages to their respective versions
    required: true
    default: '{}'

  ## Committer
  commit-username:
    description: >
      Author user.name to use.
      Defaults to triggering_actor
    required: false
    default: ${{ github.workflow }} on behalf of ${{ github.triggering_actor }}
  commit-useremail:
    description: >
      Author user.email to use.
      Defaults actor anonymous email address, `ID+USERNAME@users.noreply.github.com`
    required: false
    default: ${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com

  ## Commit message
  commit-message:
    description: >
      Subject to write into patch header
      Pystache template, getting fed {'package': 'foobar', 'value': '1.2.3'} from created from inputs.packages
    required: false
    default: ''

outputs:
  patches:
    description: >
      String containing JSON-array of the patches.
      NOTE: commit message will be extracted from the patch header,
      unless provided
    value: ${{ fromJson(steps.create-patches.outputs.patches) }}
  commits:
    description: Space-separated list of created commits
    value: ${{ fromJson(steps.commit-patches.outputs.commits) }}


runs:
  using: composite
  steps:
  - name: Install dependencies
    uses: kagekirin/gha-py-toolbox/actions/pip/install@main
    with:
      packages: >-
        lxml

  - id: prepare-patch-regex
    name: Prepare patch regex
    shell: python
    env:
      inputs_path: ${{inputs.path}}
      inputs_packages: ${{ inputs.packages }}
    run: |
      import os, sys, re, json, pprint
      from pathlib import Path
      from contextlib import chdir
      from lxml import etree

      def find_matching_nodes(xpath: str, root, packagename: str):
          return [
              node
              for node in root.xpath(xpath)
              if node.attrib["Include"].lower() == packagename.lower()
          ]

      parser = etree.XMLParser(
          remove_blank_text=True,
          remove_comments=True,
          remove_pis=True,
          strip_cdata=True,
      )

      path = str(os.getenv("inputs_path", "."))
      assert path

      inputs_packages = str(os.getenv("inputs_packages", "{}"))
      assert inputs_packages
      packages = json.loads(inputs_packages)
      assert packages
      pprint.pp(packages)

      inputs_configuration_file = str(os.getenv("inputs_configuration_file"))

      xpath = str(os.getenv("inputs_package_xpath", "//PackageVersion"))
      assert xpath

      regexes = []
      with chdir(str(os.getenv(path, "."))):
          project_config = Path(inputs_configuration_file)
          assert project_config.is_file

          root = etree.parse(project_config, parser).getroot()

          for package in packages.keys():
              nodes = find_matching_nodes(xpath=xpath, root=root, packagename=package)
              if len(nodes) == 0:
                  print("no match for", package)
              for node in nodes:
                  regex = f'<{node.tag}\\s+Include="{node.attrib["Include"]}'
                  print(f'regex for {package}:', regex)
                  regexes.append(regex)

      pprint.pp(regexes)
      # pprint.pp(packages_data)
      json_escaped = json.dumps(json.dumps(regexes, sort_keys=True))
      print(json_escaped)


  - id: verify-intermediate-outputs
    name: Verify
    shell: cat {0}
    run: |
      steps.prepare-patch-regex.outputs.regexes
      ${{steps.prepare-patch-regex.outputs.regexes}}
      ${{fromJson(steps.prepare-patch-regex.outputs.regexes)}}
      ${{ join(fromJson(fromJson(steps.prepare-patch-regex.outputs.regexes)), '\n') }}


  - id: create-patches
    uses: kagekirin/gha-py-toolbox/actions/git/get-single-line-patches@main
    with:
      path: ${{ inputs.path }}
      regex-lines: ${{ join(fromJson(fromJson(steps.prepare-patch-regex.outputs.regexes)), '\n') }}
      patch-author: ${{ inputs.commit-username }} <${{ inputs.commit-useremail }}>
      patch-subject: ${{ inputs.commit-message }}
      files: |
        ${{ inputs.configuration-file }}

  - id: commit-patches
    uses: kagekirin/gha-py-toolbox/actions/git/commit-patches@main
    with:
      path: ${{ inputs.path }}
      patches: ${{ steps.create-patches.outputs.patches }}
      commit-username: ${{ inputs.commit-username }}
      commit-useremail: ${{ inputs.commit-useremail }}
