name: DOTNET set packages versions
description: >
  Sets the package versions referenced by a given project or props file.

  Input is a JSON string of a dictionary mapping package name to its version to update.
  Returns a JSON string of a dictionary mapping package name to its updated version.

inputs:
  path:
    description: path from where to run the actions
    required: false
    default: ${{github.workspace}}

  packages:
    description: >
      JSON string of a dictionary mapping package name to its version.

      e.g. json
      ```json
      {
        "System.Text.Json": "8.0.5"
      }
      ```

      as such, the input string
      ```json
      "{\"System.Text.Json\":\"8.0.5\"}"
      ```
    required: true
  package-xpath:
    description: >
      XPath expression to locate package entries.
      WARNING: Defaults to <PackageVersion/> elements as used by Build.Packages.props.
    required: true
    default: //PackageVersion
  configuration-file:
    description: >
      Configuration file (props or csproj) to check for packages.
      Defaults to Build.Packages.props.
    required: false
    default: Build.Packages.props

outputs:
  packages:
    description: dictionary mapping the retrieved packages to their respective versions
    value: ${{ fromJson(steps.set-package-versions.outputs.packages) }}

runs:
  using: composite
  steps:
  - name: Install dependencies
    uses: kagekirin/gha-py-toolbox/actions/pip/install@main
    with:
      packages: >-
        lxml

  - id: set-package-versions
    name: Get package indices
    shell: python
    env:
      inputs_path: ${{ inputs.path }}
      inputs_packages: ${{ inputs.packages }}
      inputs_package_xpath: ${{ inputs.package-xpath }}
      inputs_configuration_file: ${{ inputs.configuration-file }}
    run: |
      import os, sys, re, json, pprint
      from pathlib import Path
      from contextlib import chdir
      from lxml import etree


      def find_matching_nodes(xpath: str, root, packagename: str):
          return [
              node
              for node in root.xpath(xpath)
              if node.attrib["Include"].lower() == packagename.lower()
          ]


      parser = etree.XMLParser(
          remove_blank_text=False,  #!< don't modify whitespace
          remove_comments=False,
          remove_pis=False,
          strip_cdata=False,
      )

      with chdir(os.getenv("inputs_path", ".")):
          packages_str = str(os.getenv("inputs_packages", "{}"))
          assert packages_str
          print(packages_str)
          packages = json.loads(packages_str)
          if not packages:
              packages = dict()
          pprint.pp(packages)

          project_config = Path(os.getenv("inputs_configuration_file"))
          assert project_config.is_file
          has_xml_declaration = project_config.read_text().startswith("<?xml")

          xpath = str(os.getenv("inputs_package_xpath", "//PackageVersion"))
          assert xpath

          root = etree.parse(project_config, parser).getroot()

          updated_packages = dict()
          for package in packages.keys():
              nodes = find_matching_nodes(xpath=xpath, root=root, packagename=package)
              for node in nodes:
                  # print(node.attrib["Include"], node.attrib["Version"])
                  node.attrib["Version"] = packages[package]
                  updated_packages[package] = packages[package]

          tree = etree.ElementTree(root)
          project_xml = (
              (
                  etree.tostring(
                      root,
                      encoding=tree.docinfo.encoding,
                      standalone=tree.docinfo.standalone,
                      xml_declaration=True,
                  )
                  if has_xml_declaration
                  else etree.tostring(root)
              )
              .decode(encoding="utf-8")
              .replace('"/>', '" />')
          )
          print(project_xml)
          project_config.write_text(project_xml)

          pprint.pp(updated_packages)

          packages_json_escaped = json.dumps(
              json.dumps(updated_packages, sort_keys=True)
          )
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              print(f"packages={packages_json_escaped}")
              print(f"packages={packages_json_escaped}", file=fh)


  - id: verify-outputs
    name: Verify
    shell: cat {0}
    run: |
      steps.set-package-versions.outputs.packages
      ${{steps.set-package-versions.outputs.packages}}

      steps.set-package-versions.outputs.packages
      ${{steps.set-package-versions.outputs.packages}}
      ${{fromJSON(steps.set-package-versions.outputs.packages)}}
